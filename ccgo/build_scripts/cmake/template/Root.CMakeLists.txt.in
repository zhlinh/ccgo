# CCGO generated file: DO NOT EDIT!
# Generated by "CCGO" Template Generator of CMake, CCGO Template Version 1.0.0
#
# Copyright 2024 zhlinh and ccgo Project Authors. All rights reserved.
# Use of this source code is governed by a MIT-style
# license that can be found at
#
# https://opensource.org/license/MIT
#
# The above copyright notice and this permission
# notice shall be included in all copies or
# substantial portions of the Software.

cmake_minimum_required(VERSION 3.14)

# Force installation to build directory instead of system directories
# This ensures all build artifacts stay within the project for easier distribution
set(CMAKE_INSTALL_PREFIX "${CMAKE_BINARY_DIR}" CACHE PATH "Installation directory" FORCE)
message(STATUS "CMAKE_INSTALL_PREFIX=${CMAKE_INSTALL_PREFIX}")

# Extract project name from CCGO.toml or fallback to directory name
# Priority: CCGO.toml [project].name > directory name
set(MAIN_PROJECT_ROOT_DIR ${CMAKE_SOURCE_DIR})

# Try to read project name from CCGO.toml
set(CCGO_TOML_PATH "${CMAKE_SOURCE_DIR}/CCGO.toml")
if(EXISTS "${CCGO_TOML_PATH}")
    file(READ "${CCGO_TOML_PATH}" CCGO_TOML_CONTENT)
    # Parse name = "xxx" from [project] section using regex
    # Match: name = "value" or name = 'value' (with optional spaces)
    string(REGEX MATCH "name[ \t]*=[ \t]*[\"']([^\"']+)[\"']" CCGO_NAME_MATCH "${CCGO_TOML_CONTENT}")
    if(CCGO_NAME_MATCH)
        string(REGEX REPLACE "name[ \t]*=[ \t]*[\"']([^\"']+)[\"']" "\\1" MAIN_PROJECT_NAME "${CCGO_NAME_MATCH}")
        message(STATUS "Project name from CCGO.toml: ${MAIN_PROJECT_NAME}")
    endif()
endif()

# Fallback: Extract project name from directory path if not found in CCGO.toml
if(NOT MAIN_PROJECT_NAME)
    string(REPLACE "/" ";" TEMP_SPLIT_ITEMS "${CMAKE_SOURCE_DIR}")  # Split path by '/'
    list(GET TEMP_SPLIT_ITEMS -1 MAIN_PROJECT_NAME)  # Get last element as project name
    message(STATUS "Project name from directory: ${MAIN_PROJECT_NAME}")
endif()

# Define project with C++ and C language support
project(${MAIN_PROJECT_NAME} CXX C)

## Include project-specific CMake utilities and compiler flags
include(${CCGO_CMAKE_DIR}/CMakeUtils.cmake)        # Custom CMake helper functions
include(${CCGO_CMAKE_DIR}/CMakeExtraFlags.cmake)   # Platform-specific compiler flags

# Add project root to include paths for header file resolution
include_directories(./)

## Auto-discover CCGO dependencies from multiple directories
# Dependencies are scanned from (in priority order):
#   1. vendor/        - Vendored dependencies (committed to git)
#   2. .ccgo/deps/    - Dependencies from 'ccgo install' (not committed)
#   3. third_party/   - Manual third-party libraries (committed to git)
include(${CCGO_CMAKE_DIR}/FindCCGODependencies.cmake)
find_ccgo_dependencies()

# Auto-enable THIRD_PARTY_OPTION if any source dependency directories exist
# This ensures dependencies are compiled even for platform builds (Android, OHOS, etc.)
if(NOT DEFINED THIRD_PARTY_OPTION)
    # Check for source dependencies in any of the dependency directories
    set(HAS_SOURCE_DEPS FALSE)
    foreach(DEP_DIR_NAME vendor .ccgo/deps third_party)
        set(DEP_BASE_DIR "${CMAKE_SOURCE_DIR}/${DEP_DIR_NAME}")
        if(EXISTS "${DEP_BASE_DIR}")
            file(GLOB DEP_SUBDIRS "${DEP_BASE_DIR}/*")
            foreach(DEP_SUBDIR ${DEP_SUBDIRS})
                if(IS_DIRECTORY "${DEP_SUBDIR}" AND EXISTS "${DEP_SUBDIR}/src")
                    set(HAS_SOURCE_DEPS TRUE)
                    message(STATUS "[CCGO] Found source dependency: ${DEP_SUBDIR}")
                    break()
                endif()
            endforeach()
            if(HAS_SOURCE_DEPS)
                break()
            endif()
        endif()
    endforeach()

    if(HAS_SOURCE_DEPS)
        set(THIRD_PARTY_OPTION ON CACHE BOOL "Build third-party source dependencies" FORCE)
        message(STATUS "[CCGO] Auto-enabled THIRD_PARTY_OPTION for source dependencies")
    endif()
endif()

## Configure and build third-party dependencies (optional)
# Subdirectories are added in file system order to ensure consistent build behavior
if(THIRD_PARTY_OPTION)
    # Set CCGO_AS_DEPENDENCY for all third-party subdirectories
    # This tells dependencies to disable their JNI_OnLoad and other standalone features
    # Keep this variable throughout the build so main target can also use it
    set(CCGO_AS_DEPENDENCY ON CACHE INTERNAL "Building as CCGO dependency")
    message(STATUS "[CCGO] Setting CCGO_AS_DEPENDENCY=ON for dependencies")
    # Define as global compile definition so all targets can see it
    add_compile_definitions(CCGO_AS_DEPENDENCY)

    # Process vendor/ directory (vendored dependencies - highest priority)
    if(EXISTS "${CMAKE_SOURCE_DIR}/vendor")
        ccgo_configure_file(
            INPUT ${CCGO_CMAKE_DIR}/template/ThirdParty.CMakeLists.txt.in
            OUTPUT ${CMAKE_SOURCE_DIR}/vendor/CMakeLists.txt
        )
        add_subdirectory(vendor ${PROJECT_NAME}-vendor)
        message(STATUS "[CCGO] Added vendor/ directory")
    endif()

    # Process .ccgo/deps/ directory (ccgo install dependencies)
    if(EXISTS "${CMAKE_SOURCE_DIR}/.ccgo/deps")
        ccgo_configure_file(
            INPUT ${CCGO_CMAKE_DIR}/template/ThirdParty.CMakeLists.txt.in
            OUTPUT ${CMAKE_SOURCE_DIR}/.ccgo/deps/CMakeLists.txt
        )
        add_subdirectory(.ccgo/deps ${PROJECT_NAME}-ccgo-deps)
        message(STATUS "[CCGO] Added .ccgo/deps/ directory")
    endif()

    # Process third_party/ directory (manual third-party - lowest priority)
    if(EXISTS "${CMAKE_SOURCE_DIR}/third_party")
        ccgo_configure_file(
            INPUT ${CCGO_CMAKE_DIR}/template/ThirdParty.CMakeLists.txt.in
            OUTPUT ${CMAKE_SOURCE_DIR}/third_party/CMakeLists.txt
        )
        add_subdirectory(third_party ${PROJECT_NAME}-third_party)
        message(STATUS "[CCGO] Added third_party/ directory")
    endif()

    # Note: We do NOT unset CCGO_AS_DEPENDENCY because main target also compiles dependency sources
    message(STATUS "[CCGO] CCGO_AS_DEPENDENCY remains active for main target")
endif()

# Add dependency include directories globally so src/ targets can find them
# This is done outside THIRD_PARTY_OPTION so headers are always available
# (even for platform builds that don't compile dependencies from source)
# Scan for include directories in all dependency locations
foreach(DEP_DIR_NAME vendor .ccgo/deps third_party)
    set(DEP_BASE_DIR "${CMAKE_SOURCE_DIR}/${DEP_DIR_NAME}")
    if(EXISTS "${DEP_BASE_DIR}")
        file(GLOB DEP_SUBDIRS "${DEP_BASE_DIR}/*")
        foreach(DEP_SUBDIR ${DEP_SUBDIRS})
            if(IS_DIRECTORY "${DEP_SUBDIR}")
                set(DEP_INCLUDE_DIR "${DEP_SUBDIR}/include")
                if(EXISTS "${DEP_INCLUDE_DIR}")
                    include_directories(${DEP_INCLUDE_DIR})
                    message(STATUS "[CCGO] Added include directory: ${DEP_INCLUDE_DIR}")
                endif()
            endif()
        endforeach()
    endif()
endforeach()

## Configure and build main source code
# Generate src/CMakeLists.txt from template
# Only copies if file doesn't exist or is CCGO-managed (has magic first line)
ccgo_configure_file(
    INPUT ${CCGO_CMAKE_DIR}/template/Src.CMakeLists.txt.in
    OUTPUT ${CMAKE_SOURCE_DIR}/src/CMakeLists.txt
)
# Add source directory with custom binary directory name
add_subdirectory(src ${PROJECT_NAME}-src)

# Discover all subdirectories within src/ for modular compilation
# This allows automatic detection of feature modules (e.g., src/network, src/storage)
set(SRC_SUB_DIR_LIST "")
get_subdirectories(SRC_SUB_DIR_LIST "${CMAKE_CURRENT_SOURCE_DIR}/src")
message(STATUS "SRC_SUB_DIR_LIST=${SRC_SUB_DIR_LIST}")

## Configure GoogleTest framework for unit testing (optional)
if(GOOGLETEST_SUPPORT)
    # Download and build GoogleTest v1.16.x from GitHub
    add_cc_external(
        NAME                      googletest
        DOWNLOAD_URL              "https://github.com/google/googletest/archive/v1.16.x.zip"
        SOURCE_DIR                "${CMAKE_BINARY_DIR}/googletest-src"
        BUILD_DIR                 "${CMAKE_BINARY_DIR}/googletest-build"
        INCLUDES                  "googletest/include googlemock/include"  # Both gtest and gmock headers
        EXTRA_CONFIGURE_COMMANDS  "-Dgtest_force_shared_crt=ON"  # Use shared CRT on Windows (MSVC)
        EXTRA_BUILD_COMMANDS      ""
        SHARED                    # Build as shared library
    )
    # Generate tests/CMakeLists.txt from template
    # Only copies if file doesn't exist or is CCGO-managed (has magic first line)
    ccgo_configure_file(
        INPUT ${CCGO_CMAKE_DIR}/template/Tests.CMakeLists.txt.in
        OUTPUT ${CMAKE_SOURCE_DIR}/tests/CMakeLists.txt
    )
    # Add tests subdirectory for unit test compilation
    add_subdirectory("tests" "${PROJECT_NAME}-tests")
endif()

## Configure Google Benchmark framework for performance testing (optional)
if(BENCHMARK_SUPPORT)
    # Download and build Google Benchmark v1.8.5 from GitHub
    add_cc_external(
        NAME                      googlebenchmark
        DOWNLOAD_URL              "https://github.com/google/benchmark/archive/v1.8.5.zip"
        SOURCE_DIR                "${CMAKE_BINARY_DIR}/googlebenchmark-src"
        BUILD_DIR                 "${CMAKE_BINARY_DIR}/googlebenchmark-build"
        EXTRA_CONFIGURE_COMMANDS  "-DBENCHMARK_ENABLE_GTEST_TESTS=OFF"  # Disable benchmark's internal tests
        EXTRA_BUILD_COMMANDS      ""
        SHARED                    # Build as shared library
    )
    # Generate benches/CMakeLists.txt from template
    # Only copies if file doesn't exist or is CCGO-managed (has magic first line)
    ccgo_configure_file(
        INPUT ${CCGO_CMAKE_DIR}/template/Benches.CMakeLists.txt.in
        OUTPUT ${CMAKE_SOURCE_DIR}/benches/CMakeLists.txt
    )
    # Add benches subdirectory for benchmark compilation
    add_subdirectory("benches" "${PROJECT_NAME}-benches")
endif()

# Output directory for final build artifacts (named after OS: Darwin.out, Linux.out, Windows.out)
set(SELF_LIBS_OUT ${CMAKE_SYSTEM_NAME}.out)

## Build Mode 1: GoogleTest Executable
# Creates a test executable when GOOGLETEST_SUPPORT is enabled
if(GOOGLETEST_SUPPORT)
    set(GOOGLETEST_NAME "${PROJECT_NAME}_googletest")
    set(CMAKE_PROJECT_NAME ${GOOGLETEST_NAME})

    # Collect all test source files (*.cc) from tests/ directory
    file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} tests/*.cc)
    list(APPEND GOOGLETEST_SUPPORT_FILES ${SELF_TEMP_SRC_FILES})

    # Build link dependencies in order: tests first, then source modules
    list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-tests)
    foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
        list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
    endforeach()

    # Collect third-party library binaries and linker flags
    set(TEMP_TARGET_SRC_LINKS "")
    set(TEMP_TARGET_LINK_FLAGS "")
    get_third_party_binary_files(TEMP_TARGET_SRC_LINKS TEMP_TARGET_LINK_FLAGS)
    list(APPEND TARGET_SRC_LINKS ${TEMP_TARGET_SRC_LINKS})

    # Add dependency libraries if they exist (may not exist if directory is empty)
    # Note: target names are derived from directory name (e.g., vendor/, deps/, third_party/)
    if(THIRD_PARTY_OPTION)
        if(TARGET ${PROJECT_NAME}-vendor)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-vendor)
        endif()
        if(TARGET ${PROJECT_NAME}-deps)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-deps)
        endif()
        if(TARGET ${PROJECT_NAME}-third_party)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-third_party)
        endif()
    endif()

    # Create test executable from collected test sources
    add_executable(${GOOGLETEST_NAME} ${GOOGLETEST_SUPPORT_FILES})

    # Apply third-party linker flags if present (e.g., -Wl,--exclude-libs for Android)
    if (NOT ${TEMP_TARGET_LINK_FLAGS} STREQUAL "")
      set_target_properties(${GOOGLETEST_NAME} PROPERTIES LINK_FLAGS ${TEMP_TARGET_LINK_FLAGS})
    endif()

    # Windows-specific: Disable DLL export/import for static library usage
    if (MSVC)
      target_compile_definitions(${GOOGLETEST_NAME} PRIVATE -DCOMM_ENABLE_EXPORTS=0)
    endif()

    # macOS/iOS-specific: Link required system frameworks
    if (APPLE)
      # Foundation, Cocoa: Core macOS/iOS APIs
      set(OTHER_FRAMEWORKS "-framework Foundation -framework Cocoa -framework IOKit -framework SystemConfiguration")
      # OpenCL, Accelerate: GPU computing and vector operations
      set(OTHER_FRAMEWORKS "${OTHER_FRAMEWORKS} -framework OpenCL -framework Accelerate")
      # Network, Security: Networking and SSL/TLS
      set(OTHER_FRAMEWORKS "${OTHER_FRAMEWORKS}  -framework Network -framework Security")
    endif()

    message(STATUS "GOOGLETEST-> TARGET_SRC_LINKS=${TARGET_SRC_LINKS}")

    # Link test executable with project modules, GoogleTest, and system libraries
    target_link_libraries(
            ${GOOGLETEST_NAME}
            ${TARGET_SRC_LINKS}     # Project modules (tests, src subdirs, third_party)
            gtest_main              # GoogleTest main() function
            ${ZLIB_LIBRARY}         # Compression library
            ${MINIZIP_LIBRARY}      # ZIP archive support
            ${OTHER_FRAMEWORKS}     # Platform-specific frameworks (macOS/iOS)
    )
    set_property(TARGET ${GOOGLETEST_NAME} PROPERTY LINKER_LANGUAGE "CXX")

    set_target_properties(${GOOGLETEST_NAME} PROPERTIES OUTPUT_NAME ${GOOGLETEST_NAME})

    # IDE-specific: Set default command-line arguments for debugging
    if (APPLE AND ${CMAKE_GENERATOR} STREQUAL "Xcode")
        set_target_properties(${GOOGLETEST_NAME} PROPERTIES XCODE_SCHEME_ARGUMENTS "--debuglog")
    elseif(MSVC)
        set_target_properties(${GOOGLETEST_NAME} PROPERTIES VS_DEBUGGER_COMMAND_ARGUMENTS "--debuglog")
        # Set as startup project in Visual Studio
        set_property(DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR} PROPERTY VS_STARTUP_PROJECT ${GOOGLETEST_NAME})
    elseif(CMAKE_GENERATOR STREQUAL "CodeLite")
        set(CMAKE_CODELITE_USE_TARGETS ON)
    endif()

    # Install test executable to output directory
    install(TARGETS ${GOOGLETEST_NAME} RUNTIME DESTINATION ${SELF_LIBS_OUT})

elseif(BENCHMARK_SUPPORT)
    ## Build Mode 2: Google Benchmark Executable
    # Creates a benchmark executable when BENCHMARK_SUPPORT is enabled
    set(BENCHMARK_NAME "${PROJECT_NAME}_benchmark")
    set(CMAKE_PROJECT_NAME ${BENCHMARK_NAME})

    # Collect all benchmark source files (*.cc) from benches/ directory
    file(GLOB SELF_TEMP_SRC_FILES
        RELATIVE ${PROJECT_SOURCE_DIR}
        "benches/*.cc"
    )
    list(APPEND BENCHMARK_SUPPORT_FILES ${SELF_TEMP_SRC_FILES})

    # Build link dependencies in order: benches first, then source modules
    list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-benches)
    foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
        list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
    endforeach()

    # Collect third-party library binaries and linker flags
    set(TEMP_TARGET_SRC_LINKS "")
    set(TEMP_TARGET_LINK_FLAGS "")
    get_third_party_binary_files(TEMP_TARGET_SRC_LINKS TEMP_TARGET_LINK_FLAGS)
    list(APPEND TARGET_SRC_LINKS ${TEMP_TARGET_SRC_LINKS})

    # Add dependency libraries if they exist (may not exist if directory is empty)
    # Note: target names are derived from directory name (e.g., vendor/, deps/, third_party/)
    if(THIRD_PARTY_OPTION)
        if(TARGET ${PROJECT_NAME}-vendor)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-vendor)
        endif()
        if(TARGET ${PROJECT_NAME}-deps)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-deps)
        endif()
        if(TARGET ${PROJECT_NAME}-third_party)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-third_party)
        endif()
    endif()

    # macOS/iOS-specific: Link required system frameworks
    if (APPLE)
      set(OTHER_FRAMEWORKS "-framework Foundation -framework Cocoa -framework IOKit -framework SystemConfiguration")
      set(OTHER_FRAMEWORKS "${OTHER_FRAMEWORKS} -framework OpenCL -framework Accelerate")
      set(OTHER_FRAMEWORKS "${OTHER_FRAMEWORKS} -framework Network -framework Security")
    endif()

    # Create benchmark executable
    add_executable(${BENCHMARK_NAME} ${file})
    target_link_libraries(
            ${BENCHMARK_NAME}
            ${TARGET_SRC_LINKS}
            benchmark_main          # Google Benchmark main() function
            ${ZLIB_LIBRARY}
            ${MINIZIP_LIBRARY}
            ${OTHER_FRAMEWORKS}
    )

    # Apply third-party linker flags if present
    if (NOT ${TEMP_TARGET_LINK_FLAGS} STREQUAL "")
      set_target_properties(${BENCHMARK_NAME} PROPERTIES LINK_FLAGS ${TEMP_TARGET_LINK_FLAGS})
    endif()

    # Windows-specific: Disable DLL export/import
    if (MSVC)
      target_compile_definitions(${BENCHMARK_NAME} PRIVATE -DCOMM_ENABLE_EXPORTS=0)
    endif()

    # Install benchmark executable to output directory
    install(TARGETS ${BENCHMARK_NAME} RUNTIME DESTINATION ${SELF_LIBS_OUT})

else()
    ## Build Mode 3: Platform-Specific Libraries (Static/Shared/Both)
    # Creates distributable libraries for Android, OHOS, etc.

    # Configure build types (can be controlled via CMake args)
    if(NOT DEFINED CCGO_BUILD_STATIC)
        set(CCGO_BUILD_STATIC ON CACHE BOOL "Build static library")
    endif()
    if(NOT DEFINED CCGO_BUILD_SHARED)
        set(CCGO_BUILD_SHARED ON CACHE BOOL "Build shared library")
    endif()

    # Validate at least one build type is enabled
    if(NOT CCGO_BUILD_STATIC AND NOT CCGO_BUILD_SHARED)
        message(FATAL_ERROR "At least one of CCGO_BUILD_STATIC or CCGO_BUILD_SHARED must be ON")
    endif()

    message(STATUS "CCGO Build Configuration:")
    message(STATUS "  - Static library: ${CCGO_BUILD_STATIC}")
    message(STATUS "  - Shared library: ${CCGO_BUILD_SHARED}")

    if(ANDROID)
        ### Android Libraries Build (Static/Shared)
        # Configure linker search paths for third-party libraries
        list(APPEND LINK_SRC_DIRS third_party)
        link_directories(${LINK_SRC_DIRS})

        # Link all source module static libraries
        foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
        endforeach()

        # Include Android-specific public API headers
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} include/${PROJECT_NAME}/api/android/*.h)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})
        source_group(api FILES ${SELF_TEMP_SRC_FILES})

        # Include Android-specific implementation headers
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} src/api/android/*.h)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})

        # Remove any test files from production build
        exclude_unittest_files(SELF_SRC_FILES)

        # Collect third-party binaries and special linker flags
        set(TEMP_TARGET_SRC_LINKS "")
        set(TEMP_TARGET_LINK_FLAGS "")
        get_third_party_binary_files(TEMP_TARGET_SRC_LINKS TEMP_TARGET_LINK_FLAGS)
        list(APPEND TARGET_SRC_LINKS ${TEMP_TARGET_SRC_LINKS})

        # Add dependency libraries if they exist
        # Note: target names are derived from directory name (e.g., vendor/, deps/, third_party/)
        if(TARGET ${PROJECT_NAME}-vendor)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-vendor)
            message(STATUS "FOUND ${PROJECT_NAME}-vendor")
        endif()
        if(TARGET ${PROJECT_NAME}-deps)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-deps)
            message(STATUS "FOUND ${PROJECT_NAME}-deps")
        endif()
        if(TARGET ${PROJECT_NAME}-third_party)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-third_party)
            message(STATUS "FOUND ${PROJECT_NAME}-third_party")
        endif()

        # Configure library search patterns for Android
        set(CMAKE_FIND_LIBRARY_PREFIXES "lib")
        set(CMAKE_FIND_LIBRARY_SUFFIXES ".so" ".a")

        # Link Android system libraries
        list(APPEND TARGET_SRC_LINKS log)  # Android logging (__android_log_print)
        list(APPEND TARGET_SRC_LINKS z)    # zlib compression (avoid find_library for fortify issues)

        # ========== Build Static Library ==========
        if(CCGO_BUILD_STATIC)
            set(STATIC_TARGET ${PROJECT_NAME}_static)
            add_library(${STATIC_TARGET} STATIC ${SELF_SRC_FILES})

            target_link_libraries(${STATIC_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (static libraries)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${STATIC_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set output name and directory
            set_target_properties(${STATIC_TARGET} PROPERTIES
                OUTPUT_NAME ${PROJECT_NAME}
                ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/static/${ANDROID_ABI}
            )

            install(TARGETS ${STATIC_TARGET}
                    ARCHIVE DESTINATION ${SELF_LIBS_OUT}/static/${ANDROID_ABI})

            message(STATUS "Building Android static library: lib${PROJECT_NAME}.a")
        endif()

        # ========== Build Shared Library ==========
        if(CCGO_BUILD_SHARED)
            set(SHARED_TARGET ${PROJECT_NAME})
            add_library(${SHARED_TARGET} SHARED ${SELF_SRC_FILES})

            target_link_libraries(${SHARED_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (prefer shared, fallback to static)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    # Use shared library if available, otherwise fall back to static
                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_SHARED_LIBRARIES)
                        target_link_libraries(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_SHARED_LIBRARIES})
                    elseif(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${SHARED_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set SO-NAME for proper runtime linking
            set_target_properties(${SHARED_TARGET} PROPERTIES
                LINK_FLAGS "-Wl,-h,lib${PROJECT_NAME}.so"
                LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared/${ANDROID_ABI}
            )

            install(TARGETS ${SHARED_TARGET}
                    LIBRARY DESTINATION ${SELF_LIBS_OUT}/shared/${ANDROID_ABI})

            message(STATUS "Building Android shared library: lib${PROJECT_NAME}.so")
        endif()

        message(STATUS "TARGET_SRC_LINKS=${TARGET_SRC_LINKS}")
    elseif(OHOS)
        ### OpenHarmony (OHOS) Libraries Build (Static/Shared)
        # Configure linker search paths for third-party libraries
        list(APPEND LINK_SRC_DIRS third_party)
        link_directories(${LINK_SRC_DIRS})

        # Link all source module static libraries
        foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
        endforeach()

        # Include OHOS-specific public API headers
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} include/${PROJECT_NAME}/api/ohos/*.h)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})
        source_group(api FILES ${SELF_TEMP_SRC_FILES})

        # Include OHOS-specific implementation headers
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} src/api/ohos/*.h)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})

        # Remove any test files from production build
        exclude_unittest_files(SELF_SRC_FILES)

        # Collect third-party binaries and special linker flags
        set(TEMP_TARGET_SRC_LINKS "")
        set(TEMP_TARGET_LINK_FLAGS "")
        get_third_party_binary_files(TEMP_TARGET_SRC_LINKS TEMP_TARGET_LINK_FLAGS)
        list(APPEND TARGET_SRC_LINKS ${TEMP_TARGET_SRC_LINKS})

        # Add dependency libraries if they exist
        # Note: target names are derived from directory name (e.g., vendor/, deps/, third_party/)
        if(TARGET ${PROJECT_NAME}-vendor)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-vendor)
            message(STATUS "FOUND ${PROJECT_NAME}-vendor")
        endif()
        if(TARGET ${PROJECT_NAME}-deps)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-deps)
            message(STATUS "FOUND ${PROJECT_NAME}-deps")
        endif()
        if(TARGET ${PROJECT_NAME}-third_party)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-third_party)
            message(STATUS "FOUND ${PROJECT_NAME}-third_party")
        endif()

        # Configure library search patterns for OHOS
        set(CMAKE_FIND_LIBRARY_PREFIXES "lib")
        set(CMAKE_FIND_LIBRARY_SUFFIXES ".so" ".a")

        # Link OHOS system libraries (HarmonyOS-specific)
        list(APPEND TARGET_SRC_LINKS libace_napi.z.so)        # NAPI bindings for Node-API compatibility
        list(APPEND TARGET_SRC_LINKS libhilog_ndk.z.so)       # HiLog logging framework
        list(APPEND TARGET_SRC_LINKS libnet_connection.so)    # Network connectivity APIs
        list(APPEND TARGET_SRC_LINKS libz.so)                 # zlib compression

        # ========== Build Static Library ==========
        if(CCGO_BUILD_STATIC)
            set(STATIC_TARGET ${PROJECT_NAME}_static)
            add_library(${STATIC_TARGET} STATIC ${SELF_SRC_FILES})

            target_link_libraries(${STATIC_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (static libraries)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${STATIC_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set output name and directory
            set_target_properties(${STATIC_TARGET} PROPERTIES
                OUTPUT_NAME ${PROJECT_NAME}
                ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/static/${OHOS_ARCH}
            )

            install(TARGETS ${STATIC_TARGET}
                    ARCHIVE DESTINATION ${SELF_LIBS_OUT}/static/${OHOS_ARCH})

            message(STATUS "Building OHOS static library: lib${PROJECT_NAME}.a")
        endif()

        # ========== Build Shared Library ==========
        if(CCGO_BUILD_SHARED)
            set(SHARED_TARGET ${PROJECT_NAME})
            add_library(${SHARED_TARGET} SHARED ${SELF_SRC_FILES})

            target_link_libraries(${SHARED_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (prefer shared, fallback to static)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    # Use shared library if available, otherwise fall back to static
                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_SHARED_LIBRARIES)
                        target_link_libraries(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_SHARED_LIBRARIES})
                    elseif(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${SHARED_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set SO-NAME for proper runtime linking
            set_target_properties(${SHARED_TARGET} PROPERTIES
                LINK_FLAGS "-Wl,-h,lib${PROJECT_NAME}.so"
                LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared/${OHOS_ARCH}
            )

            install(TARGETS ${SHARED_TARGET}
                    LIBRARY DESTINATION ${SELF_LIBS_OUT}/shared/${OHOS_ARCH})

            message(STATUS "Building OHOS shared library: lib${PROJECT_NAME}.so")
        endif()

        message(STATUS "TARGET_SRC_LINKS=${TARGET_SRC_LINKS}")

    elseif(APPLE)
        ### Apple (macOS/iOS/tvOS/watchOS) Libraries Build (Static/Shared)
        # Link all source module static libraries
        foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
        endforeach()

        # Include Apple-specific public API headers
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} include/${PROJECT_NAME}/api/apple/*.h)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})
        source_group(api FILES ${SELF_TEMP_SRC_FILES})

        # Include Apple-specific implementation
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} src/api/apple/*.h src/api/apple/*.mm src/api/apple/*.m)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})
        source_group(src\\api FILES ${SELF_TEMP_SRC_FILES})

        # Collect third-party binaries and special linker flags
        set(TEMP_TARGET_SRC_LINKS "")
        set(TEMP_TARGET_LINK_FLAGS "")
        get_third_party_binary_files(TEMP_TARGET_SRC_LINKS TEMP_TARGET_LINK_FLAGS)
        list(APPEND TARGET_SRC_LINKS ${TEMP_TARGET_SRC_LINKS})

        # Add dependency libraries if they exist
        if(TARGET ${PROJECT_NAME}-vendor)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-vendor)
            message(STATUS "FOUND ${PROJECT_NAME}-vendor")
        endif()
        if(TARGET ${PROJECT_NAME}-deps)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-deps)
            message(STATUS "FOUND ${PROJECT_NAME}-deps")
        endif()
        if(TARGET ${PROJECT_NAME}-third_party)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-third_party)
            message(STATUS "FOUND ${PROJECT_NAME}-third_party")
        endif()

        # ========== Build Static Library ==========
        if(CCGO_BUILD_STATIC)
            set(STATIC_TARGET ${PROJECT_NAME}_static)
            add_library(${STATIC_TARGET} STATIC ${SELF_SRC_FILES})

            target_link_libraries(${STATIC_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (static libraries)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${STATIC_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set output name and directory
            set_target_properties(${STATIC_TARGET} PROPERTIES
                OUTPUT_NAME ${PROJECT_NAME}
                ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/static
            )

            install(TARGETS ${STATIC_TARGET}
                    ARCHIVE DESTINATION ${SELF_LIBS_OUT}/static)

            if(IOS)
                message(STATUS "Building iOS static library: lib${PROJECT_NAME}.a")
            elseif(TVOS)
                message(STATUS "Building tvOS static library: lib${PROJECT_NAME}.a")
            elseif(WATCHOS)
                message(STATUS "Building watchOS static library: lib${PROJECT_NAME}.a")
            else()
                message(STATUS "Building macOS static library: lib${PROJECT_NAME}.a")
            endif()
        endif()

        # ========== Build Shared Library ==========
        if(CCGO_BUILD_SHARED)
            # Build .dylib for all Apple platforms (macOS, iOS, tvOS, watchOS)
            # For iOS/tvOS/watchOS, the dylib will be packaged into a .framework bundle
            # by the build script (make_dynamic_framework)
            set(SHARED_TARGET ${PROJECT_NAME})
            add_library(${SHARED_TARGET} SHARED ${SELF_SRC_FILES})

            target_link_libraries(${SHARED_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (prefer shared, fallback to static)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    # Use shared library if available, otherwise fall back to static
                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_SHARED_LIBRARIES)
                        target_link_libraries(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_SHARED_LIBRARIES})
                    elseif(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${SHARED_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            target_compile_options(${SHARED_TARGET} PRIVATE -fvisibility=hidden -fvisibility-inlines-hidden)
            target_include_directories(${SHARED_TARGET} PRIVATE ${PROJECT_SOURCE_DIR})

            set_property(TARGET ${SHARED_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set install name for proper dylib loading
            set_target_properties(${SHARED_TARGET} PROPERTIES
                INSTALL_NAME_DIR "@rpath"
                BUILD_WITH_INSTALL_RPATH TRUE
                LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared
            )

            install(TARGETS ${SHARED_TARGET}
                    LIBRARY DESTINATION ${SELF_LIBS_OUT}/shared)

            if(IOS)
                message(STATUS "Building iOS shared library: lib${PROJECT_NAME}.dylib")
            elseif(TVOS)
                message(STATUS "Building tvOS shared library: lib${PROJECT_NAME}.dylib")
            elseif(WATCHOS)
                message(STATUS "Building watchOS shared library: lib${PROJECT_NAME}.dylib")
            else()
                message(STATUS "Building macOS shared library: lib${PROJECT_NAME}.dylib")
            endif()
        endif()

        message(STATUS "TARGET_SRC_LINKS=${TARGET_SRC_LINKS}")

    elseif(MSVC OR CCGO_MSVC_COMPATIBLE OR (CMAKE_SYSTEM_NAME STREQUAL "Windows"))
        ### Windows (MSVC/MSVC-compatible) Libraries Build (Static/Shared)
        # Link all source module static libraries
        foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
        endforeach()

        # Include Windows-specific implementation
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} src/api/windows/*.h src/api/windows/*.cpp)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})
        source_group(src\\api FILES ${SELF_TEMP_SRC_FILES})

        # Collect third-party binaries and special linker flags
        set(TEMP_TARGET_SRC_LINKS "")
        set(TEMP_TARGET_LINK_FLAGS "")
        get_third_party_binary_files(TEMP_TARGET_SRC_LINKS TEMP_TARGET_LINK_FLAGS)
        list(APPEND TARGET_SRC_LINKS ${TEMP_TARGET_SRC_LINKS})

        # Add dependency libraries if they exist
        if(TARGET ${PROJECT_NAME}-vendor)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-vendor)
            message(STATUS "FOUND ${PROJECT_NAME}-vendor")
        endif()
        if(TARGET ${PROJECT_NAME}-deps)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-deps)
            message(STATUS "FOUND ${PROJECT_NAME}-deps")
        endif()
        if(TARGET ${PROJECT_NAME}-third_party)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-third_party)
            message(STATUS "FOUND ${PROJECT_NAME}-third_party")
        endif()

        # ========== Build Static Library ==========
        if(CCGO_BUILD_STATIC)
            set(STATIC_TARGET ${PROJECT_NAME}_static)
            add_library(${STATIC_TARGET} STATIC ${SELF_SRC_FILES})

            target_link_libraries(${STATIC_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (static libraries)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${STATIC_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set output name and directory
            set_target_properties(${STATIC_TARGET} PROPERTIES
                OUTPUT_NAME ${PROJECT_NAME}
                ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/static
            )

            install(TARGETS ${STATIC_TARGET}
                    ARCHIVE DESTINATION ${SELF_LIBS_OUT}/static)

            message(STATUS "Building Windows static library: ${PROJECT_NAME}.lib")
        endif()

        # ========== Build Shared Library (DLL) ==========
        if(CCGO_BUILD_SHARED)
            set(SHARED_TARGET ${PROJECT_NAME})
            add_library(${SHARED_TARGET} SHARED ${SELF_SRC_FILES})

            target_link_libraries(${SHARED_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            target_include_directories(${SHARED_TARGET} PRIVATE ${PROJECT_SOURCE_DIR})

            # Enable DLL export
            target_compile_definitions(${SHARED_TARGET} PRIVATE COMM_ENABLE_EXPORTS=1)

            set_target_properties(${SHARED_TARGET} PROPERTIES
                RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared
                LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared
                ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared
            )

            install(TARGETS ${SHARED_TARGET}
                    RUNTIME DESTINATION ${SELF_LIBS_OUT}/shared
                    LIBRARY DESTINATION ${SELF_LIBS_OUT}/shared
                    ARCHIVE DESTINATION ${SELF_LIBS_OUT}/shared)

            message(STATUS "Building Windows shared library: ${PROJECT_NAME}.dll")
        endif()

        message(STATUS "TARGET_SRC_LINKS=${TARGET_SRC_LINKS}")

    else()
        ### Linux/Unix Libraries Build (Static/Shared)
        # Link all source module static libraries
        foreach(DIR IN LISTS SRC_SUB_DIR_LIST)
            list(APPEND TARGET_SRC_LINKS ${PROJECT_NAME}-${DIR})
        endforeach()

        # Include Native API headers
        file(GLOB SELF_TEMP_SRC_FILES RELATIVE ${PROJECT_SOURCE_DIR} include/${PROJECT_NAME}/api/native/*.h)
        list(APPEND SELF_SRC_FILES ${SELF_TEMP_SRC_FILES})
        source_group(api FILES ${SELF_TEMP_SRC_FILES})

        # ========== Build Static Library ==========
        if(CCGO_BUILD_STATIC)
            set(STATIC_TARGET ${PROJECT_NAME}_static)
            add_library(${STATIC_TARGET} STATIC ${SELF_SRC_FILES})

            target_link_libraries(${STATIC_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            # Link CCGO dependencies (static libraries)
            file(GLOB CCGO_DEP_DIRS "${CMAKE_SOURCE_DIR}/third_party/*")
            foreach(CCGO_DEP_DIR ${CCGO_DEP_DIRS})
                if(IS_DIRECTORY "${CCGO_DEP_DIR}")
                    get_filename_component(CCGO_DEP_NAME ${CCGO_DEP_DIR} NAME)
                    string(TOUPPER ${CCGO_DEP_NAME} CCGO_DEP_NAME_UPPER)

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS)
                        target_include_directories(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_INCLUDE_DIRS})
                    endif()

                    if(CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES)
                        target_link_libraries(${STATIC_TARGET} PRIVATE ${CCGO_DEPENDENCY_${CCGO_DEP_NAME_UPPER}_STATIC_LIBRARIES})
                    endif()
                endif()
            endforeach()

            set_property(TARGET ${STATIC_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set output name and directory
            set_target_properties(${STATIC_TARGET} PROPERTIES
                OUTPUT_NAME ${PROJECT_NAME}
                ARCHIVE_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/static
            )

            install(TARGETS ${STATIC_TARGET}
                    ARCHIVE DESTINATION ${SELF_LIBS_OUT}/static)

            message(STATUS "Building Linux static library: lib${PROJECT_NAME}.a")
        endif()

        # ========== Build Shared Library ==========
        if(CCGO_BUILD_SHARED)
            set(SHARED_TARGET ${PROJECT_NAME})
            add_library(${SHARED_TARGET} SHARED ${SELF_SRC_FILES})

            target_link_libraries(${SHARED_TARGET} PUBLIC ${TARGET_SRC_LINKS})

            target_compile_options(${SHARED_TARGET} PRIVATE -fvisibility=hidden -fvisibility-inlines-hidden)
            target_include_directories(${SHARED_TARGET} PRIVATE ${PROJECT_SOURCE_DIR})

            set_property(TARGET ${SHARED_TARGET} PROPERTY LINKER_LANGUAGE "CXX")

            # Set SO-NAME for proper runtime linking
            set_target_properties(${SHARED_TARGET} PROPERTIES
                SOVERSION 1
                LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/shared
            )

            install(TARGETS ${SHARED_TARGET}
                    LIBRARY DESTINATION ${SELF_LIBS_OUT}/shared)

            message(STATUS "Building Linux shared library: lib${PROJECT_NAME}.so")
        endif()

    endif()
endif()
